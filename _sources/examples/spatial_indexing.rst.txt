
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/spatial_indexing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_spatial_indexing.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_spatial_indexing.py:


Spatial indexing
================

The goal of a cell tree is to quickly locate cells of an unstructured mesh.
Unstructured meshes are challenging in this regard: for a given point, we
cannot simply compute a row and column number as we would for structured data
such as rasters. The most straightforward procedure is checking every single
cell, until we find the cell which contains the point we're looking for. This
is clearly not efficient.

A cell tree is bounding volume hierarchy (BVH) which may be used as a spatial
index. A spatial index is a data structure to search a spatial object
efficiently, without exhaustively checking every cell. The implementation in
``numba_celltree`` provides four ways to search the tree:

* Locating single points
* Locating bounding boxes
* Locating convex polygons (e.g. cells of another mesh)
* Locating line segments

This example provides a basic introduction to searching a cell tree for each of
these.

We'll start by importing the required packages with matplotlib for plotting.
We will use ``meshzoo`` to create some examples meshes.

.. GENERATED FROM PYTHON SOURCE LINES 28-39

.. code-block:: default

    import os

    os.environ["NUMBA_DISABLE_JIT"] = "1"  # small examples, avoid JIT overhead

    import matplotlib.pyplot as plt
    import meshzoo
    import numpy as np
    from matplotlib.collections import LineCollection

    from numba_celltree import CellTree2d, demo








.. GENERATED FROM PYTHON SOURCE LINES 40-41

Let's go easy for a start with a rectangular mesh:

.. GENERATED FROM PYTHON SOURCE LINES 41-45

.. code-block:: default

    lower_left = (0.0, 0.0)
    upper_right = (10.0, 10.0)
    vertices, faces = meshzoo.rectangle_quad(lower_left, upper_right, n=10)








.. GENERATED FROM PYTHON SOURCE LINES 46-47

Determine the edges of the cells, and plot them.

.. GENERATED FROM PYTHON SOURCE LINES 47-53

.. code-block:: default

    node_x, node_y = vertices.transpose()
    edges = demo.edges(faces, -1)

    fig, ax = plt.subplots()
    demo.plot_edges(node_x, node_y, edges, ax, color="black")




.. image:: /examples/images/sphx_glr_spatial_indexing_001.png
    :alt: spatial indexing
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 54-58

Locating points
---------------

We'll build a cell tree first, then look for some points.

.. GENERATED FROM PYTHON SOURCE LINES 58-69

.. code-block:: default

    tree = CellTree2d(vertices, faces)
    points = np.array(
        [
            [-5.0, 1.0],
            [4.5, 2.5],
            [6.5, 4.5],
        ]
    )
    i = tree.locate_points(points)
    i





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    array([-1, 12,  5])



.. GENERATED FROM PYTHON SOURCE LINES 70-76

These numbers are the cell numbers in which we can find the points.

A value of -1 means that a point is not located in any cell.

Let's get rid of the -1 values, and take a look which cells have been found.
We'll color the found cells blue, and we'll draw the nodes to compare.

.. GENERATED FROM PYTHON SOURCE LINES 76-83

.. code-block:: default

    i = i[i != -1]

    fig, ax = plt.subplots()
    ax.scatter(*points.transpose())
    demo.plot_edges(node_x, node_y, edges, ax, color="black")
    demo.plot_edges(node_x, node_y, demo.edges(faces[i], -1), ax, color="blue", linewidth=3)




.. image:: /examples/images/sphx_glr_spatial_indexing_002.png
    :alt: spatial indexing
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 84-85

Now let's try a more exotic example.

.. GENERATED FROM PYTHON SOURCE LINES 85-94

.. code-block:: default

    vertices, faces = meshzoo.disk(5, 5)
    vertices += 1.0
    vertices *= 5.0
    node_x, node_y = vertices.transpose()
    edges = demo.edges(faces, -1)

    fig, ax = plt.subplots()
    demo.plot_edges(node_x, node_y, edges, ax, color="black")




.. image:: /examples/images/sphx_glr_spatial_indexing_003.png
    :alt: spatial indexing
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 95-98

There are certainly no rows or columns to speak of!

Let's build a new tree, and look for the same points as before.

.. GENERATED FROM PYTHON SOURCE LINES 98-107

.. code-block:: default

    tree = CellTree2d(vertices, faces)
    i = tree.locate_points(points)
    i = i[i != -1]

    fig, ax = plt.subplots()
    ax.scatter(*points.transpose())
    demo.plot_edges(node_x, node_y, edges, ax, color="black")
    demo.plot_edges(node_x, node_y, demo.edges(faces[i], -1), ax, color="blue", linewidth=3)




.. image:: /examples/images/sphx_glr_spatial_indexing_004.png
    :alt: spatial indexing
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 108-123

It should be clear by now that a point may only fall into a single cell. A
point may also be out of bounds. If a cell falls exactly on an edge, one of the
two neighbors will be chosen arbitrarily. At any rate, we can always expect
one answer per cell.

This is not the case for line segments, bounding boxes, or convex polygons: a
line may intersect multiple cells, and a bounding box or polygon may contain
multiple cells.

Locating bounding boxes
-----------------------

A search of N points will yield N answers (cell numbers). A search of N boxes
may yield M answers. To illustrate, let's look for all the cells inside of
a box.

.. GENERATED FROM PYTHON SOURCE LINES 123-137

.. code-block:: default

    box_coords = np.array(
        [
            [4.0, 8.0, 4.0, 6.0],  # xmin, xmax, ymin, ymax
        ]
    )
    box_i, cell_i = tree.locate_boxes(box_coords)

    fig, ax = plt.subplots()
    demo.plot_edges(node_x, node_y, edges, ax, color="black")
    demo.plot_edges(
        node_x, node_y, demo.edges(faces[cell_i], -1), ax, color="blue", linewidth=2
    )
    demo.plot_boxes(box_coords, ax, color="red", linewidth=3)




.. image:: /examples/images/sphx_glr_spatial_indexing_005.png
    :alt: spatial indexing
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 138-139

We can also search for multiple boxes:

.. GENERATED FROM PYTHON SOURCE LINES 139-149

.. code-block:: default

    box_coords = np.array(
        [
            [4.0, 8.0, 4.0, 6.0],
            [0.0, 8.0, 8.0, 10.0],
            [10.0, 13.0, 2.0, 8.0],
        ]
    )
    box_i, cell_i = tree.locate_boxes(box_coords)
    box_i, cell_i





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    (array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1]), array([107, 103,  94,  96,  91, 102, 101, 106, 100, 105,  92,  89,  85,
            88,  80,  84,  81,  76,  50,  75,  55,  59,   0,   5,   9,  51,
            25,  30,  26,  34, 118, 111, 115, 120, 122, 114, 117, 123, 124,
           119, 121,   4,   8,   7,   3,  15,  12,  14,  11,  18,  17,  20,
            22]))



.. GENERATED FROM PYTHON SOURCE LINES 150-155

Note that this method returns two arrays of equal length. The second array
contains the cell numbers, as usual. The first array contains the index of
the bounding box in which the respective cells fall. Note that there are only
two numbers in ``box_i``: there are no cells located in the third box, as we
can confirm visually:

.. GENERATED FROM PYTHON SOURCE LINES 155-168

.. code-block:: default

    cells_0 = cell_i[box_i == 0]
    cells_1 = cell_i[box_i == 1]

    fig, ax = plt.subplots()
    demo.plot_edges(node_x, node_y, edges, ax, color="black")
    demo.plot_edges(
        node_x, node_y, demo.edges(faces[cells_0], -1), ax, color="blue", linewidth=2
    )
    demo.plot_edges(
        node_x, node_y, demo.edges(faces[cells_1], -1), ax, color="green", linewidth=2
    )
    demo.plot_boxes(box_coords, ax, color="red", linewidth=3)




.. image:: /examples/images/sphx_glr_spatial_indexing_006.png
    :alt: spatial indexing
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 169-173

Locating cells
--------------

Similarly, we can look for other cells (convex polygons):

.. GENERATED FROM PYTHON SOURCE LINES 173-205

.. code-block:: default

    triangle_vertices = np.array(
        [
            [5.0, 3.0],
            [7.0, 3.0],
            [7.0, 5.0],
            [0.0, 6.0],
            [4.0, 4.0],
            [6.0, 10.0],
        ]
    )
    triangles = np.array(
        [
            [0, 1, 2],
            [3, 4, 5],
        ]
    )
    tri_x, tri_y = triangle_vertices.transpose()

    tri_i, cell_i = tree.locate_faces(triangle_vertices, triangles, -1)
    cells_0 = cell_i[tri_i == 0]
    cells_1 = cell_i[tri_i == 1]

    fig, ax = plt.subplots()
    demo.plot_edges(node_x, node_y, edges, ax, color="black")
    demo.plot_edges(
        node_x, node_y, demo.edges(faces[cells_0], -1), ax, color="blue", linewidth=2
    )
    demo.plot_edges(
        node_x, node_y, demo.edges(faces[cells_1], -1), ax, color="green", linewidth=2
    )
    demo.plot_edges(tri_x, tri_y, demo.edges(triangles, -1), ax, color="red", linewidth=3)




.. image:: /examples/images/sphx_glr_spatial_indexing_007.png
    :alt: spatial indexing
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 206-207

We can also compute how large the overlap is:

.. GENERATED FROM PYTHON SOURCE LINES 207-210

.. code-block:: default

    tri_i, cell_i, area = tree.intersect_faces(triangle_vertices, triangles, -1)
    area





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    array([0.00871605, 0.05399711, 0.08977243, 0.06850277, 0.27310478,
           0.44295032, 0.45148705, 0.33395494, 0.07939018, 0.19812438,
           0.28020701, 0.2439384 , 0.15635359, 0.0672785 , 0.41313708,
           0.03739642, 0.06826046, 0.58473083, 0.51557381, 0.57127098,
           0.66575332, 0.31475411, 0.44597069, 0.67310123, 0.09393931,
           0.62192747, 0.64661202, 0.67310123, 0.58778525, 0.55431165,
           0.57127098, 0.37498137, 0.54575367, 0.6021836 , 0.36411514,
           0.50808495, 0.16265269, 0.11001612, 0.24834604, 0.3601918 ,
           0.09199652, 0.6110686 , 0.58616685, 0.09873262, 0.53274277])



.. GENERATED FROM PYTHON SOURCE LINES 211-215

Let's color the faces of the mesh by their proportion of overlap. Because our
mesh is triangular, we can represent the triangles as two collections of
vectors (V, U). Then the area is half of the absolute value of the cross
product of U and V.

.. GENERATED FROM PYTHON SOURCE LINES 215-233

.. code-block:: default

    intersection_faces = faces[cell_i]
    intersection_vertices = vertices[intersection_faces]
    U = intersection_vertices[:, 1] - intersection_vertices[:, 0]
    V = intersection_vertices[:, 2] - intersection_vertices[:, 0]
    full_area = 0.5 * np.abs(np.cross(V, U))
    proportion = area / full_area

    fig, ax = plt.subplots()
    colored = ax.tripcolor(
        node_x,
        node_y,
        intersection_faces,
        proportion,
    )
    fig.colorbar(colored)
    demo.plot_edges(node_x, node_y, edges, ax, color="black")
    demo.plot_edges(tri_x, tri_y, demo.edges(triangles, -1), ax, color="red", linewidth=3)




.. image:: /examples/images/sphx_glr_spatial_indexing_008.png
    :alt: spatial indexing
    :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 234-243

Locating lines
--------------

As a final example, we will compute the intersections with two lines (edges).
This returns three arrays of equal length:

* the index of the line
* the index of the cell
* the location of the intersections

.. GENERATED FROM PYTHON SOURCE LINES 243-252

.. code-block:: default

    edge_coords = np.array(
        [
            [[0.0, 0.0], [10.0, 10.0]],
            [[0.0, 10.0], [10.0, 0.0]],
        ]
    )
    edge_i, cell_i, intersections = tree.intersect_edges(edge_coords)
    edge_i, cell_i





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    (array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
           1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]), array([112, 111, 115, 114, 110, 101, 106, 100, 105,  50,  75,   0,  25,
            30,  34,  41,  38,  46,  44,  48,  49, 100,  83,  78,  82,  79,
            80,  77,  81,  76,  50,  75,  14,   0,   5,  10,  13,   9,  17,
            20,  22,  25]))



.. GENERATED FROM PYTHON SOURCE LINES 253-256

To wrap up, we'll color the intersect faces with the length of the
intersected line segments. We can easily compute the length of each segment
with the Euclidian norm (Pythagorean distance):

.. GENERATED FROM PYTHON SOURCE LINES 256-268

.. code-block:: default

    length = np.linalg.norm(intersections[:, 1] - intersections[:, 0], axis=1)

    fig, ax = plt.subplots()
    colored = ax.tripcolor(
        node_x,
        node_y,
        faces[cell_i],
        length,
    )
    fig.colorbar(colored)
    ax.add_collection(LineCollection(edge_coords, color="red", linewidth=3))
    demo.plot_edges(node_x, node_y, edges, ax, color="black")



.. image:: /examples/images/sphx_glr_spatial_indexing_009.png
    :alt: spatial indexing
    :class: sphx-glr-single-img






.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  1.117 seconds)


.. _sphx_glr_download_examples_spatial_indexing.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: spatial_indexing.py <spatial_indexing.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: spatial_indexing.ipynb <spatial_indexing.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
